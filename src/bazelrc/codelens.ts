import * as fs from "fs";
import * as path from "path";
import * as vscode from "vscode";
import { BazelrcConfiguration } from "./configuration";

/**
 * The name of the run command
 */
export const runCommandName = "feature.bazelrc.runCommand";

/**
 * The name of the rerun command
 */
export const rerunCommandName = "feature.bazelrc.rerunCommand";

/**
 * Client implementation to the Starlark Language Server.
 */
export class BazelrcCodelens implements vscode.Disposable, vscode.CodeLensProvider {

  /** Fired when BUILD files change in the workspace. */
  private onDidChangeCodeLensesEmitter = new vscode.EventEmitter<void>();
  private disposables: vscode.Disposable[] = [];
  // represents the last run; we can replay it with a separate command
  private lastRun: runContext | undefined;

  public onDidChangeCodeLenses: vscode.Event<void>;

  constructor(
    ctx: vscode.ExtensionContext,
    private cfg: BazelrcConfiguration,
  ) {
    this.onDidChangeCodeLenses = this.onDidChangeCodeLensesEmitter.event;

    const bazelrcWatcher = vscode.workspace.createFileSystemWatcher(
      "**/*.bazelrc",
      true, // ignoreCreateEvents
      false,
      true, // ignoreDeleteEvents
    );

    bazelrcWatcher.onDidChange(
      (uri) => {
        this.onDidChangeCodeLensesEmitter.fire();
      },
      this,
      ctx.subscriptions,
    );

    this.disposables.push(bazelrcWatcher);

    this.disposables.push(vscode.commands.registerCommand(
      runCommandName,
      this.runCommand.bind(this)));

    this.disposables.push(vscode.commands.registerCommand(
      rerunCommandName,
      this.rerunCommand.bind(this)));

    this.disposables.push(vscode.languages.registerCodeLensProvider(
      [{ pattern: "**/launch.bazelrc" }],
      this,
    ));
  }

  /**
   * Runs a bazel command and streams output to the terminal.
   *
   * @param runCtx The run context.
   */
  async rerunCommand() {
    if (this.lastRun === undefined) {
      return;
    }
    vscode.tasks.executeTask(createRunCommandTask(this.lastRun));
  }

  /**
   * Runs a bazel command and streams output to the terminal.
   *
   * @param runCtx The run context.
   */
  async runCommand(runCtx: runContext | undefined) {
    if (runCtx === undefined) {
      return;
    }
    this.lastRun = runCtx;
    vscode.tasks.executeTask(createRunCommandTask(runCtx));
  }

  /**
   * Provides promisified CodeLen(s) for the given document.
   *
   * @param document A bazelrc file
   * @param token CodeLens token automatically generated by VS Code when
   *     invoking the provider
   */
  public async provideCodeLenses(
    document: vscode.TextDocument,
    token: vscode.CancellationToken,
  ): Promise<vscode.CodeLens[]> {
    if (document.isDirty) {
      // Don't show code lenses for dirty BUILD files; we can't reliably
      // determine what the build targets in it are until it is saved and we can
      // invoke `bazel query` with the updated file.
      return [];
    }

    return this.computeCodeLenses(path.dirname(document.uri.fsPath), document.getText());
  }

  /**
   * Parses the file and computes codelenses for recognized commands.
   *
   * @param bazelWorkspaceDirectory The Bazel workspace directory.
   * @param queryResult The result of the bazel query.
   */
  private computeCodeLenses(fsPath: string, text: string): vscode.CodeLens[] {
    const lines = text.split(/\r?\n/);
    const lenses: vscode.CodeLens[] = [];

    for (let i = lines.length - 1; i >= 0; i--) {
      const line = lines[i].trim();
      // skip comments
      if (line.startsWith("#")) {
        continue;
      }

      // join to prev line if this is a continuation
      if (i > 0) {
        const prevLine = lines[i - 1].trim();
        if (!prevLine.startsWith("#") && prevLine.endsWith('\\')) {
          lines[i - 1] = prevLine.slice(0, -1) + line;
          continue;
        }
      }

      // check the token for a recognized command
      const tokens = line.split(/\s+/g);
      if (tokens.length < 2) {
        continue;
      }

      let command = tokens[0];
      let matcher = "";
      const parts = command.split(":");
      if (parts.length) {
        command = parts[0];
        matcher = parts[1];
        // if (!matcher.startsWith("$")) {
        //   matcher = "$" + matcher;
        // }
      }
      let cmd: vscode.Command | undefined;

      switch (command) {
        case "build":
        case "test":
        case "query":
        case "aquery":
          cmd = createCommand({
            cwd: fsPath,
            executable: this.cfg.run.executable,
            command: command,
            matcher: matcher,
            args: tokens.slice(1),
          });
          break;
      }

      if (!cmd) {
        continue;
      }

      const range = new vscode.Range(
        new vscode.Position(i, 0),
        new vscode.Position(i, command.length));

      lenses.push(new vscode.CodeLens(range, cmd));
    }

    return lenses;
  }

  public dispose() {
    for (const disposable of this.disposables) {
      disposable.dispose();
    }
  }

}

type runContext = {
  cwd: string,
  matcher: string,
  executable: string,
  command: string,
  args: string[],
};

function createCommand(runCtx: runContext): vscode.Command {
  return {
    arguments: [runCtx],
    command: runCommandName,
    title: runCtx.command,
    tooltip: `${runCtx.command} ${runCtx.args}`,
  };
}


/**
 * Creates a new task that invokes a command.
 *
 * @param command The Bazel command to execute.
 * @param options Describes the options used to launch Bazel.
 */
export function createRunCommandTask(runCtx: runContext): vscode.Task {
  const taskDefinition = {
    type: "bazelrc",
  };
  const scope = vscode.TaskScope.Workspace;
  const name = runCtx.command;
  const source = "bazel";
  const execution = new vscode.ShellExecution(
    [runCtx.executable, runCtx.command].concat(runCtx.args).join(" "), {
    cwd: runCtx.cwd,
  });
  let problemMatchers: string[] | undefined;
  if (runCtx.matcher) {
    problemMatchers = [runCtx.matcher];
  }
  return new vscode.Task(taskDefinition, scope, name, source, execution, problemMatchers);
  // setBazelTaskInfo(task, new BazelTaskInfo(command, options));
}


/**
 * Search for the path to the directory that has the Bazel WORKSPACE file for
 * the given file.
 *
 * If multiple directories along the path to the file has files called
 * "WORKSPACE", the lowest path is returned.
 *
 * @param fsPath The path to a file in a Bazel workspace.
 * @returns The path to the directory with the Bazel WORKSPACE file if found,
 *     others undefined.
 */
export function getBazelWorkspaceFolder(fsPath: string): string | undefined {
  let dirname = fsPath;
  let iteration = 0;
  // Fail safe in case other file systems have a base dirname that doesn't
  // match the checks below. Having this failsafe guarantees that we don't
  // hang in an infinite loop.
  const maxIterations = 100;
  if (fs.statSync(fsPath).isFile()) {
    dirname = path.dirname(dirname);
  }
  do {
    const WORKSPACE_FILES = ["WORKSPACE.bazel", "WORKSPACE"];
    for (const workspaceFileName of WORKSPACE_FILES) {
      const workspace = path.join(dirname, workspaceFileName);
      try {
        fs.accessSync(workspace, fs.constants.F_OK);
        // workspace file is accessible. We have found the Bazel workspace
        // directory.
        return dirname;
      } catch (err) {
        // Intentionally do nothing; just try the next parent directory.
      }
    }
    dirname = path.dirname(dirname);
  } while (++iteration < maxIterations && dirname !== "" && dirname !== "/");

  return undefined;
}
